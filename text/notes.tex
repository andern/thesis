\documentclass[a4paper,twocolumn]{report}
\usepackage[utf8]{inputenc}
\begin{document}
\begin{enumerate}
\item Velkommen til presentasjon av masteroppgaven min
\item Fortelle litt om hvordan oppgaven har blitt til, eller oppstått
\item Goodtech og Mathconsult har utviklet et program PROMAPS, som kalkulerer
      leveransepåliteligheten i et nettverk ved å kalkulere risiko ved utfall
      av grener i nettverket
\item Kommer tilbake til dette
\item Dette er formulert som et QP-problem, eller en rekke veldig like
      QP-problemer
\item Det viser seg at QP-løseren er flaskehals. Og derfor oppdaterer
      skjermbildet seg hvert 5. minutt
\item Vi skal se på et skjermbilde av PROMAPS her i en artikkel fra Teknisk
      Ukeblad
\item Tar en titt på QP-problemet
\item Objektfunksjonen representerer leveransekostnader, det her er da
      pengeenhet per sekund, eller penger per sekund
\item $x$ er en ukjent, og representerer antall Watt vi sender over hver gren
\item $\Phi$ representerer strømtap over hver gren i Watt
\item $D$ er kostnader for å sende strøm over hver gren, penger per Joule
\item $g$ er kostnader for å generere strøm i penger per Joule
\item $c$ er leveransepris i penger per Joule, dette er da altså inntekt
\item Vi forkorter dette til en mer gjenkjennelig objektfunksjon
\item Her representerer både $H$ og $b$ kostnader. $H$ er en diagonalmatrise og
      er positivt semidefinitt, som betyr at vi jobber med et konveks
      QP-problem
\item Vi definerer et QP-problem min... underlagt $Ax = 0$, og $x$ mellom $l$
      $u$. $l$ og $u$ er nedre og øvre grenkapasitet i Watt
\item Goodtech vil løse QP-problemet vi definerte, bare med utfall i
      forskjellige grener. Vi modellerer dette ved å sette $l_i=u_i=0$
\item Vi har et QP problem $\mathcal{Q}$ som definert, uten utfall, som vi
      kaller en instans
\item Så har vi også subinstanser $\mathcal{Q}_k$ som er en instans med et
      eller flere utfall
\item Vi vil helst løse så mange subinstanser som mulig, for å få mest mulig
      nøyaktig analyse
\item For et problem med $n$ grener, er det $2^n$ subinstanser. Men usannsynlig
      det er mange utfall
\item Prøver å begrense antall subinstanser ved å sette en realistisk grense
      for antall utfall
\item Kalkulerer antall utfall ved funksjonen sigma
\item Hver variabel representerer en gren, så vi har en mengde med variabler
      som representerer utfall, som vi noterer $\mathcal{M}_k$, for
      modifikator
\item Vi har en en-til-en korrenspondanse mellom kombinasjoner av utfall og
      deres indekser
\item Vi har en subinstans $\mathcal{Q}_k$ som defineres av $\mathcal{Q}$ og
      $\mathcal{M}_k$, og vi noterer dens optimale løsning $x_k^*$
\item Jeg fikk tilsendt tre instanser av Goodtech, small, large og vlarge. Her
      ser vi verdiene på diagonalen til $H$, etter kolonne
\item Vi ser at alle verdiene er lavere enn $10^{-1}$, og at de fleste verdiene
      er lavere enn $10^{-2}$
\item Videre så ser vi her størrelsen på de tre instansene, og merk at over
      $50\%$ av diagonalelementene i $H$ er $0$ i alle tre instansene
\item Et viktig poeng å dra fram her er at verdiene i det lineære leddet er mye
      høyere enn verdiene i det kvadratiske leddet, så det gir oss motivasjon
      til å se på metoder basert på lineær programmering
\item Hva skjer hvis vi bare ignorerer det kvadratiske leddet? Har det stor
      innflytelse på optimal verdi?
\item Vi noterer en lineær Taylor-utvikling av $f$ i punktet $a$ for $T_a$,
      og da er $T_0 = b^T x$
\item Vi definerer et LP program hvor vi minimerer det lineære leddet,
      underlagt de samme sidekravene som i QP-problemet
\item Kort fortalt her så noterer vi avviket mellom optimal løsning til
      $\mathcal{L}$ og $\mathcal{Q}$ for $\Delta$
\item Vi ser her et 3D-plot som viser avviket mellom $\mathcal{L}$ og
      $\mathcal{Q}$ som en funksjon av tettheten i objektfunksjonen
\item Vi ser at tettheten i $H$ har veldig lite innflytelse på avviket
\item Vi ser også at $b$ har mye større innflytelse på avviket, men legg
      merke til at avviket er aldri større enn $5\%$, det er faktisk såvidt
      over $4\%$
\item På grunn av dette kommer altså successive linear programming inn i
      bildet. Vi vil oppnå $95\%$ av optimal verdi etter første iterasjon
      hvis vi begynner i $0$
\item Her har vi selge algoritmen, vi gjør først en taylorutvikling i det
      punktet vi står i, så løser vi $\mathcal{L}$
\item Så gjør vi et LINJESØK mellom punktet vi står i og optimale løsning til
      $\mathcal{L}$. Vi finner altså optimal målfunksjonsverdi av alle punktene
      på linja mellom de to endepunktene
\item Så flytter vi oss til det punktet vi fant i linjesøket, og fortsetter
      algoritmen helt til vi når termineringskravet vårt
\item Et eksempel. Vi minimerer dette problemet. Det optimalet punktet er her
      $x = 1$ og $y = 1$ hvor optimale objektverdi er $-2$
\item Vi ser her den lineære objektfunksjonen
\item Her har vi et bilde over det tilatte området. Det i rødt representerer
      ting som har med LP å gjøre. Vi ser her den lineære objektfunksjonen.
\item Vi gjør et linjesøk her mellom $x_0$ og $\hat{x}_0$ som vist her
\item Gjør et nytt linjesøk her, og finner da $x_2$
\item Nytt linjesøk, og havner på $x_3 = (0.96,1.02)$
\item Her ser vi stien som algoritmen tar fra startpunktet til vi terminerer
\item Etter at vi har løst en instans, så er det veldig sannsynlig at vi skal
      løse et veldig likt problem like etterpå, med en liten endring i
      høyresiden av sidekravene
\item Hvis vi gjør det, så er det mulig at vi gjør den primale løsningen
      ikke-tillatt. Vi vet at den duale likningslisten fortsatt er tillatt
      etter en endring i verdiene på høyresiden, så vi bruker den duale
      simplex-metoden til å oppnå $x_0$
\item Vi ser at hele linjesøket tar plass på denne linja, hvor optimale
      punkt ligger, så linjesøket finner $x^*$ og terminerer
\item Så slik fungerer metoden basert på SLP. Det neste vi skal se på er ikke
      en egen optimeringsalgoritme, men heller en måte å redusere antall
      subinstanser vi trenger å løse med et kall til en QP-løser
\item Så husk at vi har en mengde med grener som faller ut som vi noterer som
      $\mathcal{M}_k$. Og vi definerer en subinstans $\mathcal{Q}_k$ utifra
      $\mathcal{Q}$ og $\mathcal{M}_k$
\item Vi noterer også en mengde med variabler som er $0$ i den optimale
      løsningen til $\mathcal{Q}_k$ for $\mathcal{Z}_k$
\item Et viktig poeng å dra fram her er at hvis vi tvinger en variabel som
      allerede er $0$ i en optimal løsning til en instans, så vil ikke den
      optimale løsningen endre seg
\item I den ene instansen fra Goodtech, så viste det seg at kardinaliteten
      til $\mathcal{Z}_0 = 1749$. Dvs. at det var 1749 variabler lik null i den
      optimale løsningen. Det betyr at $2^{1749}$ subinstanser har samme
      løsning
\item Vi lager en tre-struktur over subinstanser som vi kan søke etter
      løsninger i
\item Jeg tenkte jeg skulle prøve å forklare tre-strukturen ved å vise hvordan
      man konstruere treet jeg har her, men for å spare tid så konstruerer
      vi det kun for to variabler. Vi bruker de samme mengdene som her, så
      har vi en fasit å sjekke opp mot
\item Hver node tilsvarer en subinstans, så vi har en modifikator, en optimal
      løsning, og en mengde over nuller i løsningen
\item Vi begynner først med å generere alle mulige kombinasjoner av utfall
\item Vi begynner med rot-noden, som tilsvarer instansen uten utfall
\item Og for hver node i treet, så vil hver modifikator til en barnnode være en
      utvidelse av modifikatoren til noden
\item Jeg går rett til eksperimentene jeg har utført.
\item Her ser vi fire forskjellige implementasjoner. Slp her er algoritmen
      som jeg viste fram tidligere. Clp er en åpen og gratis LP og QP-løser
      ledet av en ansatt hos IBM.
\item c-en her står for construct, som betyr at vi løser subinstansene ved
      å konstruere et tre slik som jeg gjorde.
\item n-en her står for naive, som betyr at den naivt løser alle kombinasjonene
      av subinstanser.
\item Tabellen her viser resultater av de fire implementasjonene når de løser
      \textit{small} og 28442 av dens subinstanser
\item Det er dessverre veldig tydelig at Slp ikke greier å henge med.
\item Her ser vi et loglog-plot av verdiene i tabellen.
\item I det neste eksperimentet prøver vi implementasjonene på de tre
      instansene vi fikk tildelt. Vi ser her også dessverre at Slp
      ikke henger med.
\item På de neste to eksperimentene så genererer vi tilfeldige instanser med
      lik karakteristikk som instansene fra Goodtech.
\item Vi tester her kun Clp ettersom Slp ikke greide å henge med. Vi ser her at
      tre-strukturen reduserer kjøretiden med opp til $23\%$ som $n$ øker.
\item På det siste eksperimentet så genererer vi tilfeldige instanser med $50$
      grener, og øker antall utfall.
\item Ettersom $\beta$ øker, så ser vi at vi øker hastigheten med opp mot
      $70\%$
\item Her ser vi antall CPU-sekunder brukt i gjennomsnitt til å løse en
      subinstans. Vi ser at ettersom $\beta$ øker, så beveger vi oss ned
      mot en fjerdedel av tiden per subinstans
\end{enumerate}
\end{document}
