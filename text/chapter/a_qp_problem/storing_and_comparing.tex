\section{Storing and Comparing Solutions}
Sets of variables, such as the sets $\mathcal{M}_k$ and $\mathcal{Z}_k$ can be
stored very compactly.
By using one bit per possible variable, with a total of $n$ possible variables,
each set will require exactly $n$ bits of storage.
We store these $n$ bits in a bit vector\footnote{Also known as bit array,
bitmap, bitset or bit string} of length $n$.
Each bit represent a variable, edge or column.
When a bit is set to $1$, it represents that its corresponding variable is in
the set, while a $0$ means that its \emph{not} in the set.

By representing these sets as bit vectors, we can check whether a set is a
subset of another set by performing bitwise operations. More specifically,
a simple \texttt{AND} operation will suffice.

Consider two bit vectors $A^b$ and $B^b$ representing two sets $A$ and
$B$, respectively.
By performing a bitwise \texttt{NOT} operation and a bitwise \texttt{AND}
operation on each vector, then $A$ is a subset of $B$ if and only if
$A^b~\texttt{AND}~\texttt{NOT}~B^b = 0$.
Similarly, $A$ is a subset of $B$ if and only if $B \backslash A = \emptyset$.

Take for example the three bit vectors, $D^b = 0000101001010$,
$E^b = 0110101011011$ and $F^b = 1010100010010$ representing the sets
$D, E, F$, respectively. If we want to check whether $D$ and $F$ are subsets
of $E$, we check if the answer to the following operations are equal to zero:
\[
\begin{array}{lrl}
                 & 0000101001010 & D^b \\
    \texttt{AND} & 1001010100100 & \texttt{NOT}~E^b \\ \hline
    =            & 0000000000000
\end{array}
\qquad
\begin{array}{lrl}
                 & 1010100010010 & F^b \\
    \texttt{AND} & 1001010100100 & \texttt{NOT} E^b \\ \hline
    =            & 1000000000000 \\
\end{array}
\]
We see that set is a subset bla blabla

We can also store these bit representations of vectors in a sparse format.
That way we may only need to check the bits of the set with the smallest
cardinality.
