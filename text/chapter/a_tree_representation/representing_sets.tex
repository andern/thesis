\section{Representing Sets of Variables}
Sets of variables, such as the sets $\mathcal{M}_k$ and $\mathcal{Z}_k$ can be
stored very compactly.
By using one bit per possible variable, with a total of $n$ possible variables,
each set will require exactly $n$ bits of storage.
We store these $n$ bits in a bit vector\footnote{Also known as bit array,
bitmap, bitset or bit string} of length $n$.
Each bit represents a variable. More specifically, the rightmost bit represents
$x_1$, the second rightmost bit represents $x_2$, and so on until the leftmost
bit that represents $x_n$.
When a bit is set to $1$, it means that its corresponding variable is in
the set, while a $0$ means that it is \emph{not} in the set.

By representing sets this way, we can achieve a one-to-one correspondence
between a modifier $\mathcal{M}_i$ and its index $i$ by evaluating the bit
vector of $\mathcal{M}_i$. For instance the modifier $\{ {1,4,5} \}$ can be
represented by the bit vector \texttt{11001} that evaluates to $25$, becoming
its index. Another benefit of representing sets as bit vectors is
that we can check whether a set is a
subset of another set by performing bitwise operations. More specifically,
a simple \texttt{AND} operation will suffice.

Consider two bit vectors $A^b$ and $B^b$ representing two sets $A$ and
$B$, respectively.
By performing a bitwise \texttt{NOT} operation and a bitwise \texttt{AND}
operation, $A$ is a subset of $B$ if and only if
$A^b~\texttt{AND}~\texttt{NOT}~B^b = 0$.
Similarly, $A$ is a subset of $B$ if and only if $A \backslash B = \emptyset$.

Take for example the three bit vectors, $D^b = 0110$, $E^b = 1110$ and
$F^b = 0011$ representing the sets $D, E, F$, respectively.
If we want to check whether $D$ and $F$ are subsets of $E$, we check if the
answer to the following operations are equal to zero:
\[
\begin{array}{lrl}
                 & 0110 & D^b \\
    \texttt{AND} & 0001 & \texttt{NOT}~E^b \\ \hline
    =            & 0000
\end{array}
\qquad
\begin{array}{lrl}
                 & 0011 & F^b \\
    \texttt{AND} & 0001 & \texttt{NOT}~E^b \\ \hline
    =            & 0001 \\
\end{array}
\]
From this we can conclude that $D \subseteq E$ and $F \not\subseteq E$.

We can also store sets in a sparse
format by only storing the indices of the variables that are actually in the
set.
However, this format normally requires at least $16$ bits\nolinebreak
\footnote{By storing each variable index as a \texttt{short} integer type.
The amount of bits needed is platform dependant and implementation specific,
but in \texttt{C} it is never less than $16$ bits.}
per variable in the set.
We further discuss the trade-offs of the different methods of storage in
Chapter \ref{ch:implementation}.
