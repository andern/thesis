\section{Constructing a Tree}
\label{sec:construction}
Before we can construct a tree similar to the one in Figure \ref{fig:find},
we need a slighty modified \texttt{find} that we call \texttt{mfind}.
\texttt{mfind} is modified so that it returns a tuple of a boolean and an
index.
The boolean tells us whether we found a solution to our subinstance in the
tree.
The index depends on the boolean value; if the boolean is true then the index
is the index of the subinstance with the solution.
If the boolean is false, then the index is the index of the vertex that will
become the parent of our subinstance that will be added to the tree.
Algorithm \ref{alg:mfind} shows how \texttt{mfind} works.

\input{include/mfind_algo}
To construct a tree such as the one seen in Figure \ref{fig:find}, we start
with some instance $\mathcal{Q}$, a modifier $\mathcal{M}_0 = \{ {} \}$ and
a root $v_0$.
Then, for each possible subinstance $\mathcal{Q}_i$ of $\mathcal{Q}$ such that
$|\mathcal{M}_i| \leq b$, we run \texttt{mfind} and add it to the tree if its
solution is distinct.

\input{include/construct_algo}
Algorithm \ref{alg:construct} describes an algorithm for constructing a tree
$G$, given some instance $\mathcal{Q}$ and a maximum number of breakdowns $b$.
Readers are encouraged to try to construct the tree in Figure \ref{fig:find} on
their own, following Algorithm \ref{alg:construct} and using the
$\mathcal{Z}$-sets above. Note that the tree might change if the order of
insertion changes. The combinations of modifiers under the construction of the
tree in Figure \ref{fig:find} were inserted in lexicographical order.
