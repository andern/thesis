Before we can construct a tree similar to the one in Figure \ref{fig:find},
we need a slighty modified \texttt{find} that we call \texttt{mfind}.
\texttt{mfind} is modified to take an output argument that holds a vertex,
while the function returns a boolean.
The returned boolean tells us whether the output vertex is the solution or not.
If the returned boolean is true, then the output argument is the solution
vertex, i.e. the vertex of the index that would be returned by \texttt{find}.
If the boolean is false, then the output argument is the vertex that would be
the parent vertex of the modifier we searched for if we were to insert it in
the tree.
While this can sound confusing, Algorithm \ref{alg:mfind} shows in detail how
\texttt{mfind} works.

\begin{algorithm}[ht!]
\caption{\texttt{mfind($\mathcal{M}_l$, $v_k$, $v_*$)}}
\label{alg:mfind}
\input{include/mfind_algo}
\end{algorithm}
To construct a tree such as the one seen in Figure \ref{fig:find}, we start
with some instance $\mathcal{Q}$, a modifier $\mathcal{M}_0 = \{ {} \}$ and
a root $v_0$.
Then, for each possible subinstance $\mathcal{Q}_i$ of $\mathcal{Q}$ such that
$|\mathcal{M}_i| \leq \beta$, we run \texttt{mfind} and add it to the tree if
its solution is distinct, i.e. the returned boolean is false.

\begin{algorithm}[ht!]
\caption{\texttt{construct}($\mathcal{Q}$, $\beta$)}
\label{alg:construct}
\input{include/construct_algo}
\end{algorithm}
Algorithm \ref{alg:construct} describes an algorithm for constructing a tree
$G$, given some instance $\mathcal{Q}$ and a maximum number of breakdowns
$\beta$.
Readers are encouraged to try to construct the tree in Figure \ref{fig:find} on
their own, following Algorithm \ref{alg:construct}.
Note that the tree might change if the order of
insertion changes. The combinations of modifiers under the construction of the
tree in Figure \ref{fig:find} were inserted in lexicographical order.
