\section{Solving Subinstances}
In this section, we discuss the different approaches to solving several
subinstances. As mentioned in the beginning of the chapter, the two
main approaches is to solve a limited amount of subinstances, bounded
by some $s$, or to implement a discrete event simulator that only stores
the current state of the network. First we will discuss the implementation
of the tree structure, before we move on to the two main approaches.

\subsection{Tree Structure}
All trees consists of vertices, and in our specific case, each vertex contains
two sets $\mathcal{M}$ and $\mathcal{Z}$, a solution $x^*$, and a number of
child vertices. To keep vertices as simple as possible, vertices were
implemented as simple \texttt{structs}. Each vertex \texttt{struct} looks like
this:
\begin{verbatim}
struct vertex {
    std::set<uint16_t> m;
    std::set<uint16_t> z;
    double* sol;
    std::vector<struct vertex*> children;
}
\end{verbatim}
A reader that is familiar with \texttt{C++} might notice that
\texttt{std::set} is used instead of using a bit set as we discussed
in Chapter \ref{ch:tree}, and we will come back to that later. Note that
the sets consist of indices of \texttt{uint16\_t}, which is short for
\texttt{unsigned short int}. That means that the sets are limited to
$2^{16} = 65536$ elements, and therefore also putting a limit to the size
of the QP problems that can be solved. This seems like a reasonable limit
as GoodTech wants to solve problems with $200 - 2000$ variables.
If they need to solve larger problems in the future, it is possible to change
the primitive data type.
