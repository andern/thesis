\chapter{Implementation}
Recall from Chapter \ref{ch:qp} that we discussed limiting the amount
of subinstances to solve. We did this by introducing a limit on the number of
simultaneous break-downs in the network by some $\beta$.
Another approach is to implement a discrete-event simulator (DES). Each event
occurs at a particular instant in time that changes the state of the system.
In this case, each event would either be a breakdown in the network, or that
a breakdown is fixed.

The difference in these two approaches are prominent, but they share the same
core, namely a QP solver. In this chapter we first discuss the implementation
of the solver declared in Chapter \ref{ch:slp}, before we move on to the
implementation of the two approaches of solving several subinstances.
\label{ch:implementation}

\section{Finding an LP Solver}
\input{chapter/implementation/finding_an_lp_solver}

\section{Clp}
\input{chapter/implementation/about_clp}

\section{Slp}
\input{chapter/implementation/slp}

\section{Solving Subinstances}
\input{chapter/implementation/subinstances}

\section{A Quick Overview}
In this section we present a quick overview of the different
implementations.

Although Clp is written primarily for solving linear
programs, it comes with a QP solver. This QP solver uses an implementation
of a primal-dual predictor-corrector interior point method. In addition
to Clp's QP solver, we also have the QP solver presented in Section
\ref{ch:slp}.

There are four different implementations, named
\texttt{construct\_clp}, \texttt{construct\_slp}, \texttt{naive\_clp} and
\texttt{naive\_slp}. The implementations with names ending with
\texttt{\_clp} and \texttt{\_slp} uses Clp's QP solver and Slp, respectively,
whenever a QP needs to be solved.
The \texttt{construct} implementations uses the tree structured presented
in Section \ref{ch:tree} for storing subinstances with distinct solutions.
The \texttt{naive} implementations, however, solves subinstances regardless of
whether they have distinct solutions or not.

In the next section, we present several experiments to perform on our
implementations.
