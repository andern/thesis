\appendix
\section{Codes}
\subsection{\texttt{bitset} vs \texttt{set}}
\label{app:setbench}
\begin{verbatim}

#define N 65
#define SIZE 32*N

static set<uint16_t>* copy(const bitset<SIZE>* a) {
  set<uint16_t>* res = new set<uint16_t>;
  for (uint16_t i = 0; i < SIZE; i++) {
    if (a->test(i)) res->insert(i);
  }
  return res;
}

int main() {
  srand((unsigned int)time(NULL));

  vector<bitset<SIZE>*> bitsets;

  for (int i = 0; i < 3000; i++) {
    stringstream ss;
    for (int j = 0; j < N; j++) {
      bitset<32> bs(rand());
      ss << bs.to_string();
    }
    bitsets.push_back(new bitset<SIZE>(ss.str()));
  }

  vector<set<uint16_t>*> sets;
  for (int i = 0; i < 3000; i++) {
    sets.push_back(copy(bitsets[i]));
  }

  bool fool;

  double t1 = omp_get_wtime();
  for (uint16_t i = 0; i < sets.size(); i++) {
    for (uint16_t j = 0; j < sets.size(); j++) {
      fool = isSubset(*sets[i], *sets[j]);
    }
  }
  double t2 = omp_get_wtime();

  for (uint16_t i = 0; i < bitsets.size(); i++) {
    bitset<SIZE> notb = ~(*bitsets[i]);
    for (uint16_t j = 0; j < bitsets.size(); j++) {
      fool = isSubset_bit(notb, *bitsets[j]);
    }
  }
  double t3 = omp_get_wtime();

  cout << "(" << SIZE << ", " << (t2-t1) << ")\n";
  cout << "(" << SIZE << ", " << (t3-t2) << ")\n";
}

\end{verbatim}

\subsection{next\_combination}
\label{app:nextcombination}
\begin{verbatim}
template <class BidIt>
inline bool next_combination(
BidIt n_begin, BidIt n_end,
BidIt r_begin, BidIt r_end)
{
  bool boolmarked=false;
  BidIt r_marked;

  BidIt n_it1=n_end;
  --n_it1;


  BidIt tmp_r_end=r_end;
  --tmp_r_end;

  for(BidIt r_it1=tmp_r_end;
  r_it1!=r_begin || r_it1==r_begin;
  --r_it1,--n_it1)
  {
    if(*r_it1==*n_it1 )
    { 
      if(r_it1!=r_begin)
      {
        boolmarked=true;
        r_marked=(--r_it1);
        ++r_it1;
        continue;
      }
      else
        return false;    
    }
    else
    {
      if(boolmarked==true)
      {
        BidIt n_marked;
        for (BidIt n_it2=n_begin;
        n_it2!=n_end;++n_it2)
        {
          if(*r_marked==*n_it2) {
            n_marked=n_it2;break;
          }
        }


        BidIt n_it3=++n_marked;  
        for  (BidIt r_it2=r_marked;
        r_it2!=r_end;++r_it2,++n_it3)
        {
          *r_it2=*n_it3;
        }
        return true;
      }
      for(BidIt n_it4=n_begin;
      n_it4!=n_end; ++n_it4)
        if(*r_it1==*n_it4)
        {
          *r_it1=*(++n_it4);
          return true;       
        }
    }
  }  

  return true;//will never reach
}
\end{verbatim}

\subsection{Generate Random Instance}
\label{app:random}
\begin{verbatim}
static CoinPackedMatrix packMatrix(double** m, int rows, int cols) {
    std::vector<int> row_ind_vec;
    std::vector<int> col_ind_vec;
    std::vector<double> ele_vec;
    CoinBigIndex numels = 0;

    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            double num = m[i][j];
            if (num != 0.0) {
                row_ind_vec.push_back(i);
                col_ind_vec.push_back(j);
                ele_vec.push_back(num);
                numels++;
            }   
        }   
    }   

    const int *rowIndices = &row_ind_vec[0];
    const int *colIndices = &col_ind_vec[0];
    const double *elements = &ele_vec[0];

    CoinPackedMatrix cpm(false, rowIndices, colIndices, elements, numels);
    cpm.setDimensions(rows, cols);

    return cpm;
}

static double g_randd(double min, double max) {
    double num = (double) rand() / RAND_MAX;
    return (min + (num * (max - min)));
}

static int g_randi(int min, int max) {
    return (rand() % (max-min) + min);
}

ClpModel randomInstance(int vertices, int edges, double Hzero, double bzero) {
    srand((uint16_t)time(NULL));

    /* Matrix A */
    double** m = (double**) malloc(vertices*sizeof(double*));
    for (int i = 0; i < vertices; i++)
        m[i] = (double*) calloc(edges,sizeof(double));

    int row = 0;
    for (int i = 0; i < edges; i++) {
        m[row][i] = 1;
        int r = row;
        while (r == row) row = rand() % vertices;
        m[row][i] = -1;
    }
    CoinPackedMatrix A = packMatrix(m, vertices, edges);

    for (int i = 0; i < vertices; i++)
        free(m[i]);
    free(m);

    /* Matrix H */
    std::vector<int> row_ind_vec;
    std::vector<int> col_ind_vec;
    std::vector<double> ele_vec;
    int numels = 0;

    for (int i = 0; i < edges; i++) {
        /* If not 0 */
        if (((double)rand() / RAND_MAX) >= Hzero) {
            double num = g_randd(0.00001, 0.01);
            row_ind_vec.push_back(i);
            col_ind_vec.push_back(i);
            ele_vec.push_back(num);
            numels++;
        }
    }
    const int *rowIndices = &row_ind_vec[0];
    const int *colIndices = &col_ind_vec[0];
    const double *elements = &ele_vec[0];

    CoinPackedMatrix H(false, rowIndices, colIndices, elements, numels);
    H.setDimensions(edges, edges);

    /* Vector b */
    double* b = (double*) calloc(edges,sizeof(double));

    for (int i = 0; i < edges; i++) {
        /* If not 0 */
        if (((double)rand() / RAND_MAX) >= bzero) {
            double num = g_randi(10, 70);
            if (num >= 30) num = -num;
            b[i] = num;
        }
    }

    /* Vector lb */
    double* lb = (double*) malloc(edges*sizeof(double));
    for (int i = 0; i < edges; i++) {
        lb[i] = -g_randd(0.0, 1000.0);
    }

    /* Vector ub */
    double* ub = (double*) malloc(edges*sizeof(double));
    for (int i = 0; i < edges; i++) {
        ub[i] = g_randd(0.0, 1000.0);
    }

    ClpSimplex model;

    model.loadProblem(A, lb, ub, b, 0, 0);
    model.loadQuadraticObjective(H);

    free(b);
    free(lb);
    free(ub);

    return model;
}
\end{verbatim}

\section{Tables}
\subsection{Results From Experiment 1}
\label{app:exp1}
\begin{tabular}{lrr}
     $n$ & cClp               & nClp \\ \hline
     100 &   0.1              &   0.2 \\
     200 &   0.5              &   0.7 \\
     300 &   1.3              &   1.7 \\
     400 &   2.8              &   3.5 \\
     500 &   4.9              &   5.9 \\
     600 &   7.7              &  10.9 \\
     700 &  13.2              &  15.6 \\
     800 &  20.3              &  26.2 \\
     900 &  29.8              &  36.7 \\
    1000 &  42.1              &  53.0 \\
    1100 &  57.2              &  75.4 \\
    1200 &  76.4              & 107.4 \\
    1300 & 107.4              & 137.0 \\
    1400 & 141.7              & 180.3 \\
    1500 & 181.5              & 234.5 \\
    1600 & 216.7              & 300.6 \\
    1700 & 295.8              & 381.4 \\
    1800 & 366.5              & 483.6 \\
    1900 & 448.0              & 611.5 \\
    2000 & 547.1              & 710.2
\end{tabular}

